// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ParameterValidation.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Assertion.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Assertion.Recipes
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text.RegularExpressions;

    using static System.FormattableString;

    /// <summary>
    /// Contains all validations that can be applied to a <see cref="AssertionTracker"/>.
    /// </summary>
#if !OBeautifulCodeAssertionRecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Assertion.Recipes", "See package version number")]
    internal
#else
    public
#endif
        static partial class Verifications
    {
        /// <summary>
        /// Validates that the reference type or nullable parameter is null.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeNullInternal,
                ValidationName = nameof(BeNull),
                TypeValidations = MustBeNullableTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the reference type or nullable parameter is not null.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeNullInternal,
                ValidationName = nameof(NotBeNull),
                TypeValidations = MustBeNullableTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the bool or bool? parameter is true.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeTrue(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeTrueInternal,
                ValidationName = nameof(BeTrue),
                TypeValidations = MustBeBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the bool or bool? parameter is not true.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeTrue(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeTrueInternal,
                ValidationName = nameof(NotBeTrue),
                TypeValidations = MustBeBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the bool or bool? parameter is false.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeFalse(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeFalseInternal,
                ValidationName = nameof(BeFalse),
                TypeValidations = MustBeBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the bool? or bool? parameter is not false.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeFalse(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeFalseInternal,
                ValidationName = nameof(NotBeFalse),
                TypeValidations = MustBeBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the string parameter is neither null nor whitespace.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeNullNorWhiteSpace(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeNullNorWhiteSpaceInternal,
                ValidationName = nameof(NotBeNullNorWhiteSpace),
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the string parameter is null or not white space.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeNullOrNotWhiteSpace(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeNullOrNotWhiteSpaceInternal,
                ValidationName = nameof(BeNullOrNotWhiteSpace),
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the guid or guid? parameter is empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeEmptyGuid(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeEmptyGuidInternal,
                ValidationName = nameof(BeEmptyGuid),
                TypeValidations = MustBeGuidTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the guid or guid? parameter is not empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeEmptyGuid(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeEmptyGuidInternal,
                ValidationName = nameof(NotBeEmptyGuid),
                TypeValidations = MustBeGuidTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the string parameter is empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeEmptyString(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeEmptyStringInternal,
                ValidationName = nameof(BeEmptyString),
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the string parameter is not empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeEmptyString(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeEmptyStringInternal,
                ValidationName = nameof(NotBeEmptyString),
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IEnumerable parameter is empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeEmptyEnumerable(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeEmptyEnumerableInternal,
                ValidationName = nameof(BeEmptyEnumerable),
                TypeValidations = MustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IEnumerable parameter is not empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeEmptyEnumerable(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeEmptyEnumerableInternal,
                ValidationName = nameof(NotBeEmptyEnumerable),
                TypeValidations = MustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} parameter is empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeEmptyDictionary(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeEmptyDictionaryInternal,
                ValidationName = nameof(BeEmptyDictionary),
                TypeValidations = MustBeDictionaryTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} parameter is not empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeEmptyDictionary(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeEmptyDictionaryInternal,
                ValidationName = nameof(NotBeEmptyDictionary),
                TypeValidations = MustBeDictionaryTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IEnumerable parameter contains at least one null element.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker ContainSomeNullElements(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = ContainSomeNullElementsInternal,
                ValidationName = nameof(ContainSomeNullElements),
                TypeValidations = MustBeEnumerableOfNullableTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IEnumerable parameter does not contain any null elements.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotContainAnyNullElements(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotContainAnyNullElementsInternal,
                ValidationName = nameof(NotContainAnyNullElements),
                TypeValidations = MustBeEnumerableOfNullableTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} parameter contains at least one null value.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker ContainSomeKeyValuePairsWithNullValue(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = ContainSomeKeyValuePairsWithNullValueInternal,
                ValidationName = nameof(ContainSomeKeyValuePairsWithNullValue),
                TypeValidations = MustBeDictionaryOfNullableTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} parameter does not contain any null values.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotContainAnyKeyValuePairsWithNullValue(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotContainAnyKeyValuePairsWithNullValueInternal,
                ValidationName = nameof(NotContainAnyKeyValuePairsWithNullValue),
                TypeValidations = MustBeDictionaryOfNullableTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IEnumerable parameter is not null nor empty.
        /// </summary>
        /// <remarks>
        /// This validation is effectively the same as <see cref="NotBeEmptyEnumerable"/> and exists for completeness.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeNullNorEmptyEnumerable(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeEmptyEnumerableInternal,
                ValidationName = nameof(NotBeNullNorEmptyEnumerable),
                TypeValidations = MustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);

            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IEnumerable parameter is not null nor empty nor contains any null elements.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeNullNorEmptyEnumerableNorContainAnyNulls(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validationName = nameof(NotBeNullNorEmptyEnumerableNorContainAnyNulls);

            var validation1 = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeEmptyEnumerableInternal,
                ValidationName = validationName,
                TypeValidations = MustBeEnumerableOfNullableTypeValidations,
                Data = data,
            };

            var validation2 = new Validation
            {
                Because = because,
                ValueValidationHandler = NotContainAnyNullElementsInternal,
                ValidationName = validationName,
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.Validate(validation1);
            assertionTracker.Validate(validation2);

            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} parameter is not null nor empty nor contains any null values.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeNullNorEmptyDictionaryNorContainAnyNullValues(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validationName = nameof(NotBeNullNorEmptyDictionaryNorContainAnyNullValues);

            var validation1 = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeEmptyDictionaryInternal,
                ValidationName = validationName,
                TypeValidations = MustBeDictionaryOfNullableTypeValidations,
                Data = data,
            };

            var validation2 = new Validation
            {
                Because = because,
                ValueValidationHandler = NotContainAnyKeyValuePairsWithNullValueInternal,
                ValidationName = validationName,
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.Validate(validation1);
            assertionTracker.Validate(validation2);

            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} parameter is not null nor empty.
        /// </summary>
        /// <remarks>
        /// This validation is effectively the same as <see cref="NotBeEmptyDictionary"/> and exists for completeness.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeNullNorEmptyDictionary(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeEmptyDictionaryInternal,
                ValidationName = nameof(NotBeNullNorEmptyDictionary),
                TypeValidations = MustBeDictionaryTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);

            return assertionTracker;
        }

        /// <summary>
        /// Validates that the parameter is equal to default(T).
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeDefault(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeDefaultInternal,
                ValidationName = nameof(BeDefault),
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the parameter is not equal to default(T).
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeDefault(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeDefaultInternal,
                ValidationName = nameof(NotBeDefault),
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IComparable or IComparable{T} parameter is less than some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the parameter value to.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeLessThan<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeLessThanInternal,
                ValidationName = nameof(BeLessThan),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IComparable or IComparable{T} parameter is not less than some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the parameter value to.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeLessThan<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeLessThanInternal,
                ValidationName = nameof(NotBeLessThan),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IComparable or IComparable{T} parameter is greater than some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the parameter value to.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeGreaterThan<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeGreaterThanInternal,
                ValidationName = nameof(BeGreaterThan),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IComparable or IComparable{T} parameter is not greater than some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the parameter value to.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeGreaterThan<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeGreaterThanInternal,
                ValidationName = nameof(NotBeGreaterThan),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IComparable or IComparable{T} parameter is less than or equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the parameter value to.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeLessThanOrEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeLessThanOrEqualToInternal,
                ValidationName = nameof(BeLessThanOrEqualTo),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IComparable or IComparable{T} parameter is not less or equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the parameter value to.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeLessThanOrEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeLessThanOrEqualToInternal,
                ValidationName = nameof(NotBeLessThanOrEqualTo),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IComparable or IComparable{T} parameter is greater than or equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the parameter value to.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeGreaterThanOrEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeGreaterThanOrEqualToInternal,
                ValidationName = nameof(BeGreaterThanOrEqualTo),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IComparable or IComparable{T} parameter is not greater than or equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the parameter value to.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeGreaterThanOrEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeGreaterThanOrEqualToInternal,
                ValidationName = nameof(NotBeGreaterThanOrEqualTo),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the parameter is equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the parameter value to.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeEqualToInternal,
                ValidationName = nameof(BeEqualTo),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = EqualsTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the parameter is not equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the parameter value to.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeEqualToInternal,
                ValidationName = nameof(NotBeEqualTo),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = EqualsTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IComparable or IComparable{T} parameter is within a specified range.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="minimum">The minimum comparison value (start of the range).</param>
        /// <param name="maximum">The maximum comparison value (end of the range).</param>
        /// <param name="endpointDelineation">Optional instruction on whether the range is inclusive or exclusive of the endpoints.  Default is to include both the <paramref name="minimum"/> and <paramref name="maximum"/> in the range.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeInRange<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T minimum,
            T maximum,
            Range endpointDelineation = Range.IncludesMinimumAndMaximum,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (endpointDelineation != Range.IncludesMinimumAndMaximum)
            {
                throw new NotImplementedException("This endpoint delineation is not yet implemented: " + endpointDelineation);
            }

            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeInRangeInternal,
                ValidationName = nameof(BeInRange),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(minimum),
                        Value = minimum,
                        ValueType = typeof(T),
                    },
                    new ValidationParameter
                    {
                        Name = nameof(maximum),
                        Value = maximum,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IComparable or IComparable{T} parameter is not within a specified range.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="minimum">The minimum comparison value (start of the range).</param>
        /// <param name="maximum">The maximum comparison value (end of the range).</param>
        /// <param name="endpointDelineation">Optional instruction on whether the range is inclusive or exclusive of the endpoints.  Default is to include both the <paramref name="minimum"/> and <paramref name="maximum"/> in the range.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeInRange<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T minimum,
            T maximum,
            Range endpointDelineation = Range.IncludesMinimumAndMaximum,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (endpointDelineation != Range.IncludesMinimumAndMaximum)
            {
                throw new NotImplementedException("This endpoint delineation is not yet implemented: " + endpointDelineation + ".");
            }

            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeInRangeInternal,
                ValidationName = nameof(NotBeInRange),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(minimum),
                        Value = minimum,
                        ValueType = typeof(T),
                    },
                    new ValidationParameter
                    {
                        Name = nameof(maximum),
                        Value = maximum,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IEnumerable parameter contains a specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="itemToSearchFor">The item to search for.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker Contain<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T itemToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = ContainInternal,
                ValidationName = nameof(Contain),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(itemToSearchFor),
                        Value = itemToSearchFor,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = ContainmentTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the IEnumerable parameter does not contain a specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="itemToSearchFor">The item to search for.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotContain<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T itemToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotContainInternal,
                ValidationName = nameof(NotContain),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(itemToSearchFor),
                        Value = itemToSearchFor,
                        ValueType = typeof(T),
                    },
                },
                TypeValidations = ContainmentTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the string parameter is alphabetic.
        /// </summary>
        /// <remarks>
        /// An empty string is considered to be alphabetic.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="otherAllowedCharacters">Optional set of other characters that are allowed (e.g. '-').  Default is none (strict definition of alphabetic).</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeAlphabetic(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<char> otherAllowedCharacters = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeAlphabeticInternal,
                ValidationName = nameof(BeAlphabetic),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(otherAllowedCharacters),
                        Value = otherAllowedCharacters,
                        ValueType = typeof(IReadOnlyCollection<char>),
                        ValueToStringFunc = () =>
                        {
                            string result;
                            if (otherAllowedCharacters == null)
                            {
                                result = NullValueToString;
                            }
                            else if (otherAllowedCharacters.Count == 0)
                            {
                                result = EmptyEnumerableToString;
                            }
                            else
                            {
                                var otherAllowedCharactersToString = otherAllowedCharacters.Select(_ => Invariant($"'{_}'")).ToArray();
                                result = Invariant($"[{string.Join(", ", otherAllowedCharactersToString)}]");
                            }

                            return result;
                        },
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the string parameter is alphanumeric.
        /// </summary>
        /// <remarks>
        /// An empty string is considered to be alphanumeric.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="otherAllowedCharacters">Optional set of other characters that are allowed (e.g. '-').  Default is none (strict definition of alphanumeric).</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeAlphanumeric(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<char> otherAllowedCharacters = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeAlphanumericInternal,
                ValidationName = nameof(BeAlphanumeric),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(otherAllowedCharacters),
                        Value = otherAllowedCharacters,
                        ValueType = typeof(IReadOnlyCollection<char>),
                        ValueToStringFunc = () =>
                        {
                            string result;
                            if (otherAllowedCharacters == null)
                            {
                                result = NullValueToString;
                            }
                            else if (otherAllowedCharacters.Count == 0)
                            {
                                result = EmptyEnumerableToString;
                            }
                            else
                            {
                                var otherAllowedCharactersToString = otherAllowedCharacters.Select(_ => Invariant($"'{_}'")).ToArray();
                                result = Invariant($"[{string.Join(", ", otherAllowedCharactersToString)}]");
                            }

                            return result;
                        },
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the string parameter is in the ASCII printable set (ASCII 32-126).
        /// </summary>
        /// <remarks>
        /// An empty string is considered to be printable.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="treatNewLineAsPrintable">Optional value indicating whether to treat newline as printable.  Default value is false; newline will not be treated as printable.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeAsciiPrintable(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            bool treatNewLineAsPrintable = false,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeAsciiPrintableInternal,
                ValidationName = nameof(BeAsciiPrintable),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(treatNewLineAsPrintable),
                        Value = treatNewLineAsPrintable,
                        ValueType = typeof(bool),
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);

            return assertionTracker;
        }

        /// <summary>
        /// Validates that a regex finds a match in the string parameter.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="regex">The regex to use.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeMatchedByRegex(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Regex regex,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (regex == null)
            {
                throw new ArgumentNullException(nameof(regex));
            }

            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = BeMatchedByRegexInternal,
                ValidationName = nameof(BeMatchedByRegex),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(regex),
                        Value = regex,
                        ValueType = typeof(Regex),
                        ValueToStringFunc = regex.ToString,
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that a regex does not find a match in the string parameter.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="regex">The regex to use.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotBeMatchedByRegex(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Regex regex,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (regex == null)
            {
                throw new ArgumentNullException(nameof(regex));
            }

            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotBeMatchedByRegexInternal,
                ValidationName = nameof(NotBeMatchedByRegex),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(regex),
                        Value = regex,
                        ValueType = typeof(Regex),
                        ValueToStringFunc = regex.ToString,
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the string parameter starts with a specified string.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The string value to find.</param>
        /// <param name="comparisonType">Optional value that determines how the string parameter and <paramref name="comparisonValue"/> are compared.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker StartWith(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string comparisonValue,
            StringComparison? comparisonType = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValue == null)
            {
                throw new ArgumentNullException(nameof(comparisonValue));
            }

            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = StartWithInternal,
                ValidationName = nameof(StartWith),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ValueType = typeof(string),
                    },
                    new ValidationParameter
                    {
                        Name = nameof(comparisonType),
                        Value = comparisonType,
                        ValueType = typeof(StringComparison),
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Validates that the string parameter does not starts with a specified string.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The string value to find.</param>
        /// <param name="comparisonType">Optional value that determines how the string parameter and <paramref name="comparisonValue"/> are compared.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker NotStartWith(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string comparisonValue,
            StringComparison? comparisonType = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValue == null)
            {
                throw new ArgumentNullException(nameof(comparisonValue));
            }

            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = NotStartWithInternal,
                ValidationName = nameof(NotStartWith),
                ValidationParameters = new[]
                {
                    new ValidationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ValueType = typeof(string),
                    },
                    new ValidationParameter
                    {
                        Name = nameof(comparisonType),
                        Value = comparisonType,
                        ValueType = typeof(StringComparison),
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }

        /// <summary>
        /// Always throws.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the validation, used in the exception message if the parameter fails this validation.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static AssertionTracker BeOfTypeThatDoesNotExist(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var validation = new Validation
            {
                Because = because,
                ApplyBecause = applyBecause,
                ValueValidationHandler = null,
                ValidationName = nameof(BeOfTypeThatDoesNotExist),
                TypeValidations = AlwaysThrowTypeValidations,
                Data = data,
            };

            assertionTracker.Validate(validation);
            return assertionTracker;
        }
    }
}
