// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Verifications.Internal.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Assertion.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Assertion.Recipes
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Linq;
    using System.Text.RegularExpressions;

    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "A generalized assertion library is going to require lots of types.")]
#if !OBeautifulCodeAssertionRecipesProject
    internal
#else
    public
#endif
        static partial class Verifications
    {
        private static readonly HashSet<char> AlphaNumericCharactersHashSet =
            new HashSet<char>(
                new char[0]
                    .Concat(Enumerable.Range(48, 10).Select(Convert.ToChar))
                    .Concat(Enumerable.Range(65, 26).Select(Convert.ToChar))
                    .Concat(Enumerable.Range(97, 26).Select(Convert.ToChar)));

        private static readonly HashSet<char> AlphabeticCharactersHashSet =
            new HashSet<char>(
                new char[0]
                    .Concat(Enumerable.Range(65, 26).Select(Convert.ToChar))
                    .Concat(Enumerable.Range(97, 26).Select(Convert.ToChar)));

        private static void BeNullInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            if (!ReferenceEquals(verification.Value, null))
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeNullExceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void NotBeNullInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            if (ReferenceEquals(verification.Value, null))
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeNullExceptionMessageSuffix);

                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentNullException(null, exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void BeTrueInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = ReferenceEquals(verification.Value, null) || ((bool)verification.Value != true);
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeTrueExceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void NotBeTrueInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldNotThrow = ReferenceEquals(verification.Value, null) || ((bool)verification.Value == false);
            if (!shouldNotThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeTrueExceptionMessageSuffix);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void BeFalseInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = ReferenceEquals(verification.Value, null) || (bool)verification.Value;
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeFalseExceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void NotBeFalseInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldNotThrow = ReferenceEquals(verification.Value, null) || (bool)verification.Value;
            if (!shouldNotThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeFalseExceptionMessageSuffix);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void NotBeNullNorWhiteSpaceInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var shouldThrow = string.IsNullOrWhiteSpace((string)verification.Value);
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeNullNorWhiteSpaceExceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void BeNullOrNotWhiteSpaceInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = !ReferenceEquals(verification.Value, null) && string.IsNullOrWhiteSpace((string)verification.Value);
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeNullOrNotWhiteSpaceExceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void BeEmptyGuidInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = ReferenceEquals(verification.Value, null) || ((Guid)verification.Value != Guid.Empty);
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeEmptyGuidExceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void NotBeEmptyGuidInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = (!ReferenceEquals(verification.Value, null)) && ((Guid)verification.Value == Guid.Empty);
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeEmptyGuidExceptionMessageSuffix);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1820:TestForEmptyStringsUsingStringLength", Justification = "string.IsNullOrEmpty does not work here")]
        private static void BeEmptyStringInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = (string)verification.Value != string.Empty;

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeEmptyStringExceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1820:TestForEmptyStringsUsingStringLength", Justification = "string.IsNullOrEmpty does not work here")]
        private static void NotBeEmptyStringInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = (string)verification.Value == string.Empty;

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeEmptyStringExceptionMessageSuffix);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "unused", Justification = "Cannot iterate without a local")]
        private static void BeEmptyEnumerableInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var valueAsEnumerable = verification.Value as IEnumerable;
            var shouldThrow = false;

            // ReSharper disable once PossibleNullReferenceException
            foreach (var unused in valueAsEnumerable)
            {
                shouldThrow = true;
                break;
            }

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeEmptyEnumerableExceptionMessageSuffix);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "unused", Justification = "Cannot iterate without a local")]
        private static void NotBeEmptyEnumerableInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var valueAsEnumerable = verification.Value as IEnumerable;
            var shouldThrow = true;

            // ReSharper disable once PossibleNullReferenceException
            foreach (var unused in valueAsEnumerable)
            {
                shouldThrow = false;
                break;
            }

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeEmptyEnumerableExceptionMessageSuffix);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "unused", Justification = "Cannot iterate without a local")]
        private static void BeEmptyDictionaryInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var valueAsDictionary = verification.Value as IDictionary;

            // ReSharper disable once PossibleNullReferenceException
            var shouldThrow = valueAsDictionary.Count != 0;
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeEmptyDictionaryExceptionMessageSuffix);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "unused", Justification = "Cannot iterate without a local")]
        private static void NotBeEmptyDictionaryInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var valueAsDictionary = verification.Value as IDictionary;

            // ReSharper disable once PossibleNullReferenceException
            var shouldThrow = valueAsDictionary.Count == 0;
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeEmptyDictionaryExceptionMessageSuffix);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void ContainSomeNullElementsInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var valueAsEnumerable = verification.Value as IEnumerable;
            var shouldThrow = true;

            // ReSharper disable once PossibleNullReferenceException
            foreach (var unused in valueAsEnumerable)
            {
                if (ReferenceEquals(unused, null))
                {
                    shouldThrow = false;
                    break;
                }
            }

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, ContainSomeNullElementsExceptionMessageSuffix);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void NotContainAnyNullElementsInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var valueAsEnumerable = verification.Value as IEnumerable;
            var shouldThrow = false;

            // ReSharper disable once PossibleNullReferenceException
            foreach (var unused in valueAsEnumerable)
            {
                if (ReferenceEquals(unused, null))
                {
                    shouldThrow = true;
                    break;
                }
            }

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotContainAnyNullElementsExceptionMessageSuffix);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void ContainSomeKeyValuePairsWithNullValueInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var valueAsEnumerable = verification.Value as IEnumerable;
            var shouldThrow = true;

            // ReSharper disable once PossibleNullReferenceException
            foreach (var keyValuePair in valueAsEnumerable)
            {
                if (ReferenceEquals(((dynamic)keyValuePair).Value, null))
                {
                    shouldThrow = false;
                    break;
                }
            }

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, ContainSomeKeyValuePairsWithNullValueExceptionMessageSuffix);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void NotContainAnyKeyValuePairsWithNullValueInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var valueAsEnumerable = verification.Value as IEnumerable;
            var shouldThrow = false;

            // ReSharper disable once PossibleNullReferenceException
            foreach (var keyValuePair in valueAsEnumerable)
            {
                if (ReferenceEquals(((dynamic)keyValuePair).Value, null))
                {
                    shouldThrow = true;
                    break;
                }
            }

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotContainAnyKeyValuePairsWithNullValueExceptionMessageSuffix);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void BeDefaultInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var defaultValue = GetDefaultValue(verification.ValueType);
            var shouldThrow = !EqualUsingDefaultEqualityComparer(verification.ValueType, verification.Value, defaultValue);
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeDefaultExceptionMessageSuffix, Include.FailingValue | Include.GenericType);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void NotBeDefaultInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var defaultValue = GetDefaultValue(verification.ValueType);
            var shouldThrow = EqualUsingDefaultEqualityComparer(verification.ValueType, verification.Value, defaultValue);
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeDefaultExceptionMessageSuffix, Include.GenericType);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void BeLessThanInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = CompareUsingDefaultComparer(verification.ValueType, verification.Value, verification.VerificationParameters[0].Value) != CompareOutcome.Value1LessThanValue2;
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeLessThanExceptionMessageSuffix, Include.FailingValue | Include.GenericType);

                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentOutOfRangeException(exceptionMessage, (Exception)null).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void NotBeLessThanInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = CompareUsingDefaultComparer(verification.ValueType, verification.Value, verification.VerificationParameters[0].Value) == CompareOutcome.Value1LessThanValue2;
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeLessThanExceptionMessageSuffix, Include.FailingValue | Include.GenericType);

                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentOutOfRangeException(exceptionMessage, (Exception)null).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void BeGreaterThanInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = CompareUsingDefaultComparer(verification.ValueType, verification.Value, verification.VerificationParameters[0].Value) != CompareOutcome.Value1GreaterThanValue2;
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeGreaterThanExceptionMessageSuffix, Include.FailingValue | Include.GenericType);

                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentOutOfRangeException(exceptionMessage, (Exception)null).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void NotBeGreaterThanInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = CompareUsingDefaultComparer(verification.ValueType, verification.Value, verification.VerificationParameters[0].Value) == CompareOutcome.Value1GreaterThanValue2;
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeGreaterThanExceptionMessageSuffix, Include.FailingValue | Include.GenericType);

                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentOutOfRangeException(exceptionMessage, (Exception)null).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void BeLessThanOrEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = CompareUsingDefaultComparer(verification.ValueType, verification.Value, verification.VerificationParameters[0].Value) == CompareOutcome.Value1GreaterThanValue2;
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeLessThanOrEqualToExceptionMessageSuffix, Include.FailingValue | Include.GenericType);

                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentOutOfRangeException(exceptionMessage, (Exception)null).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void NotBeLessThanOrEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = CompareUsingDefaultComparer(verification.ValueType, verification.Value, verification.VerificationParameters[0].Value) != CompareOutcome.Value1GreaterThanValue2;
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeLessThanOrEqualToExceptionMessageSuffix, Include.FailingValue | Include.GenericType);

                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentOutOfRangeException(exceptionMessage, (Exception)null).AddData(verification.Data).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void BeGreaterThanOrEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = CompareUsingDefaultComparer(verification.ValueType, verification.Value, verification.VerificationParameters[0].Value) == CompareOutcome.Value1LessThanValue2;
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeGreaterThanOrEqualToExceptionMessageSuffix, Include.FailingValue | Include.GenericType);

                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentOutOfRangeException(exceptionMessage, (Exception)null).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void NotBeGreaterThanOrEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = CompareUsingDefaultComparer(verification.ValueType, verification.Value, verification.VerificationParameters[0].Value) != CompareOutcome.Value1LessThanValue2;
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeGreaterThanOrEqualToExceptionMessageSuffix, Include.FailingValue | Include.GenericType);

                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentOutOfRangeException(exceptionMessage, (Exception)null).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void BeEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = !EqualUsingDefaultEqualityComparer(verification.ValueType, verification.Value, verification.VerificationParameters[0].Value);
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeEqualToExceptionMessageSuffix, Include.FailingValue | Include.GenericType);
                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentOutOfRangeException(exceptionMessage, (Exception)null).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void NotBeEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            var shouldThrow = EqualUsingDefaultEqualityComparer(verification.ValueType, verification.Value, verification.VerificationParameters[0].Value);
            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeEqualToExceptionMessageSuffix, Include.GenericType);
                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentOutOfRangeException(exceptionMessage, (Exception)null).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void BeInRangeInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            ThrowIfMalformedRange(verification.VerificationParameters);

            var shouldThrow = (CompareUsingDefaultComparer(verification.ValueType, verification.Value, verification.VerificationParameters[0].Value) == CompareOutcome.Value1LessThanValue2) ||
                              (CompareUsingDefaultComparer(verification.ValueType, verification.Value, verification.VerificationParameters[1].Value) == CompareOutcome.Value1GreaterThanValue2);

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeInRangeExceptionMessageSuffix, Include.FailingValue | Include.GenericType);

                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentOutOfRangeException(exceptionMessage, (Exception)null).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void NotBeInRangeInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            ThrowIfMalformedRange(verification.VerificationParameters);

            var shouldThrow = (CompareUsingDefaultComparer(verification.ValueType, verification.Value, verification.VerificationParameters[0].Value) != CompareOutcome.Value1LessThanValue2) &&
                              (CompareUsingDefaultComparer(verification.ValueType, verification.Value, verification.VerificationParameters[1].Value) != CompareOutcome.Value1GreaterThanValue2);

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeInRangeExceptionMessageSuffix, Include.GenericType);

                if (verification.IsElementInEnumerable)
                {
                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
                else
                {
                    var exception = new ArgumentOutOfRangeException(exceptionMessage, (Exception)null).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void ContainInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var valueAsEnumerable = (IEnumerable)verification.Value;
            var searchForItem = verification.VerificationParameters[0].Value;
            var elementType = verification.VerificationParameters[0].Type;
            foreach (var element in valueAsEnumerable)
            {
                if (EqualUsingDefaultEqualityComparer(elementType, element, searchForItem))
                {
                    return;
                }
            }

            var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, ContainExceptionMessageSuffix, Include.GenericType, genericTypeOverride: elementType);

            var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

            throw exception;
        }

        private static void NotContainInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var valueAsEnumerable = (IEnumerable)verification.Value;
            var searchForItem = verification.VerificationParameters[0].Value;
            var elementType = verification.VerificationParameters[0].Type;
            foreach (var element in valueAsEnumerable)
            {
                if (EqualUsingDefaultEqualityComparer(elementType, element, searchForItem))
                {
                    var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotContainExceptionMessageSuffix, Include.GenericType, genericTypeOverride: elementType);

                    var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                    throw exception;
                }
            }
        }

        private static void BeAlphabeticInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            BeInCharacterSetInternal(assertionTracker, verification, AlphabeticCharactersHashSet, BeAlphabeticExceptionMessageSuffix);
        }

        private static void BeAlphanumericInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            BeInCharacterSetInternal(assertionTracker, verification, AlphaNumericCharactersHashSet, BeAlphanumericExceptionMessageSuffix);
        }

        private static void BeInCharacterSetInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            HashSet<char> allowedCharactersHashSet,
            string exceptionMessageSuffix)
        {
            NotBeNullInternal(assertionTracker, verification);

            var otherAllowedCharacters = (IReadOnlyCollection<char>)verification.VerificationParameters[0].Value;

            var stringValue = (string)verification.Value;

            bool shouldThrow;
            if (otherAllowedCharacters == null)
            {
                shouldThrow = stringValue.Any(_ => !allowedCharactersHashSet.Contains(_));
            }
            else
            {
                allowedCharactersHashSet = new HashSet<char>(allowedCharactersHashSet);
                foreach (var otherAllowedCharacter in otherAllowedCharacters)
                {
                    allowedCharactersHashSet.Add(otherAllowedCharacter);
                }

                shouldThrow = stringValue.Any(_ => !allowedCharactersHashSet.Contains(_));
            }

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, exceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void BeAsciiPrintableInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var treatNewLineAsPrintable = (bool)verification.VerificationParameters[0].Value;

            var stringValue = (string)verification.Value;

            if (treatNewLineAsPrintable)
            {
                stringValue = stringValue.Replace(Environment.NewLine, string.Empty);
            }

            var shouldThrow = stringValue.Any(_ => ((int)_ < 32) || ((int)_ > 126));

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeAsciiPrintableExceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void BeMatchedByRegexInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var regex = (Regex)verification.VerificationParameters[0].Value;

            var stringValue = (string)verification.Value;

            var shouldThrow = !regex.IsMatch(stringValue);

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, BeMatchedByRegexExceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        private static void NotBeMatchedByRegexInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var regex = (Regex)verification.VerificationParameters[0].Value;

            var stringValue = (string)verification.Value;

            var shouldThrow = regex.IsMatch(stringValue);

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotBeMatchedByRegexExceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Globalization", "CA1307:SpecifyStringComparison", MessageId = "System.String.StartsWith(System.String)", Justification = "User can specify whether to verify with comparisonType or not.")]
        private static void StartWithInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var subjectValue = (string)verification.Value;
            var comparisonValue = (string)verification.VerificationParameters[0].Value;
            var comparisonType = (StringComparison?)verification.VerificationParameters[1].Value;

            var shouldThrow = comparisonType == null
                ? !subjectValue.StartsWith(comparisonValue)
                : !subjectValue.StartsWith(comparisonValue, (StringComparison) comparisonType);

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, StartWithExceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Globalization", "CA1307:SpecifyStringComparison", MessageId = "System.String.StartsWith(System.String)", Justification = "User can specify whether to verify with comparisonType or not.")]
        private static void NotStartWithInternal(
            AssertionTracker assertionTracker,
            Verification verification)
        {
            NotBeNullInternal(assertionTracker, verification);

            var subjectValue = (string)verification.Value;
            var comparisonValue = (string)verification.VerificationParameters[0].Value;
            var comparisonType = (StringComparison?)verification.VerificationParameters[1].Value;

            var shouldThrow = comparisonType == null
                ? subjectValue.StartsWith(comparisonValue)
                : subjectValue.StartsWith(comparisonValue, (StringComparison)comparisonType);

            if (shouldThrow)
            {
                var exceptionMessage = BuildArgumentExceptionMessage(assertionTracker, verification, NotStartWithExceptionMessageSuffix, Include.FailingValue);

                var exception = new ArgumentException(exceptionMessage).AddData(verification.Data);

                throw exception;
            }
        }
    }
}
