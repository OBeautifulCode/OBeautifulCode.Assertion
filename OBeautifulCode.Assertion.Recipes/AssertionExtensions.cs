// --------------------------------------------------------------------------------------------------------------------
// <copyright file="AssertionExtensions.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Assertion.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Assertion.Recipes
{
    using System;
    using System.Collections;
    using System.Runtime.CompilerServices;
    using OBeautifulCode.Type.Recipes;

    /// <summary>
    /// Assertion related extension methods, excluding verification.
    /// </summary>
#if !OBeautifulCodeAssertionRecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Assertion.Recipes", "See package version number")]
    internal
#else
    public
#endif
        static class AssertionExtensions
    {
        /// <summary>
        /// Specifies the name of the subject.
        /// </summary>
        /// <typeparam name="TSubject">The type of subject.</typeparam>
        /// <param name="value">The value of the subject.</param>
        /// <param name="name">The name of the subject.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker Named<TSubject>(
            [ValidatedNotNull] this TSubject value,
            string name)
        {
            if (value is AssertionTracker tracker)
            {
                ThrowImproperUseOfFrameworkIfDetected(tracker, AssertionTrackerShould.NotExist);
            }

            var result = new AssertionTracker
            {
                SubjectValue = value,
                SubjectName = name,
                SubjectType = typeof(TSubject),
                Actions = Actions.Named,
            };

            return result;
        }

        /// <summary>
        /// Initializes a subject for verification.
        /// </summary>
        /// <typeparam name="TSubject">The type of the subject.</typeparam>
        /// <param name="value">The value of the subject.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static AssertionTracker Must<TSubject>(
            [ValidatedNotNull] this TSubject value)
        {
            // it a tracker itself? pass-thru
            if (value is AssertionTracker tracker)
            {
                ThrowImproperUseOfFrameworkIfDetected(tracker, AssertionTrackerShould.BeNamed, AssertionTrackerShould.NotBeMusted, AssertionTrackerShould.NotBeEached, AssertionTrackerShould.NotBeVerified);

                tracker.Actions |= Actions.Musted;

                return tracker;
            }

            var subjectType = typeof(TSubject);

            if (!ReferenceEquals(value, null))
            {
                if (subjectType.IsAnonymousFastCheck())
                {
                    // with one property?  that's the subject we are trying to apply verification to.
                    var properties = subjectType.GetProperties();
                    if (properties.Length == 1)
                    {
                        var trackerForSubjectInAnonymousObject = new AssertionTracker
                        {
                            SubjectValue = properties[0].GetValue(value, null),
                            SubjectName = properties[0].Name,
                            SubjectType = properties[0].PropertyType,
                            Actions = Actions.Musted,
                        };

                        return trackerForSubjectInAnonymousObject;
                    }
                    else
                    {
                        ThrowImproperUseOfFramework();
                    }
                }
            }

            var trackerForDirectlySpecifiedSubject = new AssertionTracker
            {
                SubjectValue = value,
                Actions = Actions.Musted,
                SubjectType = subjectType,
            };

            return trackerForDirectlySpecifiedSubject;
        }

        /// <summary>
        /// Specifies that the verifications should be applied
        /// to the elements of the <see cref="IEnumerable"/> subject.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <returns>
        /// The assertion tracker in a state where verifications will be
        /// applied to the elements of the <see cref="IEnumerable"/> subject.
        /// </returns>
        public static AssertionTracker Each(
            [ValidatedNotNull] this AssertionTracker assertionTracker)
        {
            ThrowImproperUseOfFrameworkIfDetected(assertionTracker, AssertionTrackerShould.BeMusted, AssertionTrackerShould.NotBeEached);

            assertionTracker.Actions |= Actions.Eached;

            return assertionTracker;
        }

        /// <summary>
        /// Specifies another verification.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker And(
            [ValidatedNotNull] this AssertionTracker assertionTracker)
        {
            ThrowImproperUseOfFrameworkIfDetected(assertionTracker, AssertionTrackerShould.BeMusted, AssertionTrackerShould.BeVerifiedAtLeastOnce);

            return assertionTracker;
        }

        /// <summary>
        /// Throws an exception if an improper use of the framework is detected.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="assertionTrackerShoulds">Specifies what should or should not be true about the assertion tracker.</param>
        internal static void ThrowImproperUseOfFrameworkIfDetected(
            [ValidatedNotNull] AssertionTracker assertionTracker,
            params AssertionTrackerShould[] assertionTrackerShoulds)
        {
            bool shouldThrow = false;
            if (assertionTracker == null)
            {
                shouldThrow = true;
            }
            else if (assertionTracker.SubjectType == null)
            {
                shouldThrow = true;
            }
            else
            {
                foreach (var assertionTrackerShould in assertionTrackerShoulds)
                {
                    switch (assertionTrackerShould)
                    {
                        case AssertionTrackerShould.NotExist:
                            shouldThrow = true;
                            break;
                        case AssertionTrackerShould.BeNamed:
                            shouldThrow = !assertionTracker.Actions.HasFlag(Actions.Named);
                            break;
                        case AssertionTrackerShould.NotBeNamed:
                            shouldThrow = assertionTracker.Actions.HasFlag(Actions.Named);
                            break;
                        case AssertionTrackerShould.BeMusted:
                            shouldThrow = !assertionTracker.Actions.HasFlag(Actions.Musted);
                            break;
                        case AssertionTrackerShould.NotBeMusted:
                            shouldThrow = assertionTracker.Actions.HasFlag(Actions.Musted);
                            break;
                        case AssertionTrackerShould.BeEached:
                            shouldThrow = !assertionTracker.Actions.HasFlag(Actions.Eached);
                            break;
                        case AssertionTrackerShould.NotBeEached:
                            shouldThrow = assertionTracker.Actions.HasFlag(Actions.Eached);
                            break;
                        case AssertionTrackerShould.BeVerifiedAtLeastOnce:
                            shouldThrow = !assertionTracker.Actions.HasFlag(Actions.VerifiedAtLeastOnce);
                            break;
                        case AssertionTrackerShould.NotBeVerified:
                            shouldThrow = assertionTracker.Actions.HasFlag(Actions.VerifiedAtLeastOnce);
                            break;
                        default:
                            shouldThrow = true;
                            break;
                    }

                    if (shouldThrow)
                    {
                        break;
                    }
                }
            }

            if (shouldThrow)
            {
                ThrowImproperUseOfFramework();
            }
        }

        /// <summary>
        /// Throws an exception to inform the caller that the framework is being used improperly.
        /// </summary>
        /// <param name="message">Optional message to prepend.</param>
        internal static void ThrowImproperUseOfFramework(
            string message = null)
        {
            // We throw an ImproperUseOfAssertionFrameworkException rather than an
            // ArgumentException or InvalidOperationException so that this category of
            // problem can be clearly differentiated from a verification failure.
            // If we didn't throw here:
            //   - if tracker == null then NullReferenceException would be thrown soon after, when the tracker
            //     gets used, except that it would not have a nice message like the one below.  In addition, we would
            //     have to sprinkle Code Analysis suppressions throughout the project, for CA1062.
            //   - if tracker != null then the user doesn't understand how the framework is designed to be used
            //     and what the framework's limitations are.  Some negative outcome might occur (throwing when
            //     not expected or not throwing when expected).
            message = message == null ? ParameterValidation.ImproperUseOfFrameworkExceptionMessage : message + "  " + ParameterValidation.ImproperUseOfFrameworkExceptionMessage;

            throw new ImproperUseOfAssertionFrameworkException(message);
        }
    }
}
