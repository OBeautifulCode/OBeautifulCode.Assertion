// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ParameterValidation.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Validation source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Validation.Recipes
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;

    using static System.FormattableString;

    /// <summary>
    /// Contains all validations that can be applied to a <see cref="Parameter"/>.
    /// </summary>
#if !OBeautifulCodeValidationRecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Validation", "See package version number")]
    internal
#else
    public
#endif
        static class ParameterValidation
    {
        private delegate void TypeValidation(string validationName, bool isElementInEnumerable, Type valueType);

        private delegate void ValueValidation(object value, Type valueType, string parameterName, string because, bool isElementInEnumerable);

        /// <summary>
        /// Validates that the reference type or nullable parameter is null.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter BeNull(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                ThrowIfTypeCannotBeNull,
            };

            parameter.Validate(BeNull, nameof(BeNull), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Validates that the reference type or nullable parameter is not null.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter NotBeNull(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                ThrowIfTypeCannotBeNull,
            };

            parameter.Validate(NotBeNull, nameof(NotBeNull), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Validates that the bool or bool? parameter is true.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter BeTrue(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                (validationName, isElementInEnumerable, parameterValueType) => ThrowIfNotOfType(validationName, isElementInEnumerable, parameterValueType, typeof(bool), typeof(bool?)),
            };

            parameter.Validate(BeTrue, nameof(BeTrue), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Validates that the bool or bool? parameter is not true.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter NotBeTrue(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                (validationName, isElementInEnumerable, parameterValueType) => ThrowIfNotOfType(validationName, isElementInEnumerable, parameterValueType, typeof(bool), typeof(bool?)),
            };

            parameter.Validate(NotBeTrue, nameof(NotBeTrue), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Validates that the bool or bool? parameter is false.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter BeFalse(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                (validationName, isElementInEnumerable, parameterValueType) => ThrowIfNotOfType(validationName, isElementInEnumerable, parameterValueType, typeof(bool), typeof(bool?)),
            };

            parameter.Validate(BeFalse, nameof(BeFalse), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Validates that the bool? or bool? parameter is not false.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter NotBeFalse(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                (validationName, isElementInEnumerable, parameterValueType) => ThrowIfNotOfType(validationName, isElementInEnumerable, parameterValueType, typeof(bool), typeof(bool?)),
            };

            parameter.Validate(NotBeFalse, nameof(NotBeFalse), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Validates that the string parameter is neither null nor whitespace.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter NotBeNullNorWhiteSpace(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                (validationName, isElementInEnumerable, parameterValueType) => ThrowIfNotOfType(validationName, isElementInEnumerable, parameterValueType, typeof(string)),
            };

            parameter.Validate(NotBeNullNorWhiteSpace, nameof(NotBeNullNorWhiteSpace), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Validates that the guid or guid? is empty.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter BeEmptyGuid(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                (validationName, isElementInEnumerable, parameterValueType) => ThrowIfNotOfType(validationName, isElementInEnumerable, parameterValueType, typeof(Guid), typeof(Guid?)),
            };

            parameter.Validate(BeEmptyGuid, nameof(BeEmptyGuid), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Validates that the string parameter is empty.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter BeEmptyString(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                (validationName, isElementInEnumerable, parameterValueType) => ThrowIfNotOfType(validationName, isElementInEnumerable, parameterValueType, typeof(string)),
            };

            parameter.Validate(BeEmptyString, nameof(BeEmptyString), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Validates that the IEnumerable parameter is empty.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter BeEmptyEnumerable(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                (validationName, isElementInEnumerable, parameterValueType) => ThrowIfNotOfType(validationName, isElementInEnumerable, parameterValueType, typeof(IEnumerable)),
            };

            parameter.Validate(BeEmptyEnumerable, nameof(BeEmptyEnumerable), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Validates that the guid or guid? parameter is not empty.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter NotBeEmptyGuid(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                (validationName, isElementInEnumerable, parameterValueType) => ThrowIfNotOfType(validationName, isElementInEnumerable, parameterValueType, typeof(Guid), typeof(Guid?)),
            };

            parameter.Validate(NotBeEmptyGuid, nameof(NotBeEmptyGuid), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Validates that the string parameter is not empty.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter NotBeEmptyString(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                (validationName, isElementInEnumerable, parameterValueType) => ThrowIfNotOfType(validationName, isElementInEnumerable, parameterValueType, typeof(string)),
            };

            parameter.Validate(NotBeEmptyString, nameof(NotBeEmptyString), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Validates that the IEnumerable parameter is not empty.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter NotBeEmptyEnumerable(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                (validationName, isElementInEnumerable, parameterValueType) => ThrowIfNotOfType(validationName, isElementInEnumerable, parameterValueType, typeof(IEnumerable)),
            };

            parameter.Validate(NotBeEmptyEnumerable, nameof(NotBeEmptyEnumerable), typeValidations, because);
            return parameter;
        }

        /// <summary>
        /// Always throws.
        /// </summary>
        /// <param name="parameter">The parameter to validate.</param>
        /// <param name="because">Rationale for the validation.  Replaces the default exception message constructed by this validation.</param>
        /// <returns>
        /// The validated parameter.
        /// </returns>
        public static Parameter BeOfNonExistentType(
            this Parameter parameter,
            string because = null)
        {
            var typeValidations = new TypeValidation[]
            {
                Throw,
            };

            parameter.Validate(null, nameof(BeOfNonExistentType), typeValidations, because);
            return parameter;
        }

        private static void Validate(
            this Parameter parameter,
            ValueValidation valueValidation,
            string validationName,
            IReadOnlyCollection<TypeValidation> typeValidations,
            string because)
        {
            ParameterValidator.ThrowOnImproperUseOfFramework(parameter, ParameterShould.BeMusted);

            if (parameter.HasBeenEached)
            {
                if (parameter.Value is IEnumerable valueAsEnumerable)
                {
                    var enumerableType = GetEnumerableGenericType(parameter.ValueType);

                    foreach (var typeValidation in typeValidations)
                    {
                        typeValidation(validationName, isElementInEnumerable: true, valueType: enumerableType);
                    }

                    foreach (var element in valueAsEnumerable)
                    {
                        valueValidation(element, enumerableType, parameter.Name, because, isElementInEnumerable: true);
                    }
                }
                else
                {
                    // Each() calls:
                    // - ThrowOnImproperUseOfFramework when the parameter value is null
                    // - ThrowOnUnexpectedType when the parameter value is not an Enumerable
                    // so if we get here, the caller is trying to hack the framework
                    ParameterValidator.ThrowOnImproperUseOfFramework();
                }
            }
            else
            {
                foreach (var typeValidation in typeValidations)
                {
                    typeValidation(validationName, isElementInEnumerable: false, valueType: parameter.ValueType);
                }

                valueValidation(parameter.Value, parameter.ValueType, parameter.Name, because, isElementInEnumerable: false);
            }

            parameter.HasBeenValidated = true;
        }

        private static Type GetEnumerableGenericType(
            Type type)
        {
            // adapted from: https://stackoverflow.com/a/17713382/356790

            Type result;
            if (type.IsArray)
            {
                // type is array, shortcut
                result = type.GetElementType();
            }
            else if (type.IsGenericType && (type.GetGenericTypeDefinition() == typeof(IEnumerable<>)))
            {
                // type is IEnumerable<T>
                result = type.GetGenericArguments()[0];
            }
            else
            {
                // type implements/extends IEnumerable<T>
                result = type
                    .GetInterfaces()
                    .Where(_ => _.IsGenericType && _.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                    .Select(_ => _.GenericTypeArguments[0])
                    .FirstOrDefault();

                if (result == null)
                {
                    result = typeof(object);
                }
            }

            return result;
        }

        private static void Throw(
            string validationName,
            bool isElementInEnumerable,
            Type valueType)
        {
            var parameterValueTypeName = valueType.GetFriendlyTypeName();
            throw new InvalidCastException(Invariant($"validationName: {validationName}, isElementInEnumerable: {isElementInEnumerable}, parameterValueTypeName: {parameterValueTypeName}"));
        }

        private static void ThrowIfTypeCannotBeNull(
            string validationName,
            bool isElementInEnumerable,
            Type valueType)
        {
            if (valueType.IsValueType && (Nullable.GetUnderlyingType(valueType) == null))
            {
                ParameterValidator.ThrowOnUnexpectedTypes(validationName, isElementInEnumerable, "Any Reference Type", "Nullable<T>");
            }            
        }

        private static void ThrowIfNotOfType(
            string validationName,
            bool isElementInEnumerable,
            Type valueType,
            params Type[] validTypes)
        {
            if ((!validTypes.Contains(valueType)) && (!validTypes.Any(_ => _.IsAssignableFrom(valueType))))
            {
                ParameterValidator.ThrowOnUnexpectedTypes(validationName, isElementInEnumerable, validTypes);
            }
        }

        private static string BuildExceptionMessage(
            string parameterName,
            string because,
            bool isElementInEnumerable,
            string exceptionMessageSuffix)
        {
            if (because != null)
            {
                return because;
            }

            var parameterNameQualifier = parameterName == null ? string.Empty : Invariant($" '{parameterName}'");
            var enumerableQualifier = isElementInEnumerable ? " contains an element that" : string.Empty;
            var result = Invariant($"parameter{parameterNameQualifier}{enumerableQualifier} {exceptionMessageSuffix}");
            return result;
        }

        private static void BeNull(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            if (!ReferenceEquals(value, null))
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is not null");
                throw new ArgumentException(exceptionMessage);
            }
        }

        private static void NotBeNull(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            if (ReferenceEquals(value, null))
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is null");
                if (isElementInEnumerable)
                {
                    throw new ArgumentException(exceptionMessage);
                }
                else
                {
                    throw new ArgumentNullException(null, exceptionMessage);
                }
            }
        }

        private static void BeTrue(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            var shouldThrow = ReferenceEquals(value, null) || ((bool)value != true);
            if (shouldThrow)
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is not true");
                throw new ArgumentException(exceptionMessage);
            }
        }

        private static void NotBeTrue(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            var shouldNotThrow = ReferenceEquals(value, null) || ((bool)value == false);
            if (!shouldNotThrow)
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is true");
                throw new ArgumentException(exceptionMessage);
            }
        }

        private static void BeFalse(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            var shouldThrow = ReferenceEquals(value, null) || (bool)value;
            if (shouldThrow)
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is not false");
                throw new ArgumentException(exceptionMessage);
            }
        }

        private static void NotBeFalse(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            var shouldNotThrow = ReferenceEquals(value, null) || (bool)value;
            if (!shouldNotThrow)
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is false");
                throw new ArgumentException(exceptionMessage);
            }
        }

        private static void NotBeNullNorWhiteSpace(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            NotBeNull(value, valueType, parameterName, because, isElementInEnumerable);

            var shouldThrow = string.IsNullOrWhiteSpace((string)value);
            if (shouldThrow)
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is white space");
                throw new ArgumentException(exceptionMessage);
            }
        }

        private static void BeEmptyGuid(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            var shouldThrow = ReferenceEquals(value, null) || ((Guid)value != Guid.Empty);
            if (shouldThrow)
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is not an empty guid");
                throw new ArgumentException(exceptionMessage);
            }
        }

        private static void BeEmptyString(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            var shouldThrow = (string)value != string.Empty;

            if (shouldThrow)
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is not an empty string");
                throw new ArgumentException(exceptionMessage);
            }
        }

        private static void BeEmptyEnumerable(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            NotBeNull(value, valueType, parameterName, because, isElementInEnumerable);

            var valueAsEnumerable = value as IEnumerable;
            var shouldThrow = false;

            // ReSharper disable once PossibleNullReferenceException
            foreach (var unused in valueAsEnumerable)
            {
                shouldThrow = true;
                break;
            }

            if (shouldThrow)
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is not an empty enumerable");
                throw new ArgumentException(exceptionMessage);
            }
        }

        private static void NotBeEmptyGuid(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            var shouldThrow = (!ReferenceEquals(value, null)) && ((Guid)value == Guid.Empty);
            if (shouldThrow)
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is an empty guid");
                throw new ArgumentException(exceptionMessage);
            }            
        }

        private static void NotBeEmptyString(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            var shouldThrow = (string)value == string.Empty;

            if (shouldThrow)
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is an empty string");
                throw new ArgumentException(exceptionMessage);
            }
        }

        private static void NotBeEmptyEnumerable(
            object value,
            Type valueType,
            string parameterName,
            string because,
            bool isElementInEnumerable)
        {
            NotBeNull(value, valueType, parameterName, because, isElementInEnumerable);

            var valueAsEnumerable = value as IEnumerable;
            var shouldThrow = true;

            // ReSharper disable once PossibleNullReferenceException
            foreach (var unused in valueAsEnumerable)
            {
                shouldThrow = false;
                break;
            }

            if (shouldThrow)
            {
                var exceptionMessage = BuildExceptionMessage(parameterName, because, isElementInEnumerable, "is an empty enumerable");
                throw new ArgumentException(exceptionMessage);
            }
        }
    }
}
