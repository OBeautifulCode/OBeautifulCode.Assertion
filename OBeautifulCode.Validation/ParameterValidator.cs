// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ParameterValidator.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Validation source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Validation.Recipes
{
    using System;
    using System.Collections;

    using static System.FormattableString;

    /// <summary>
    /// Extension methods.
    /// </summary>
#if !OBeautifulCodeValidationRecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Validation", "See package version number")]
    internal
#else
    public
#endif
        static class ParameterValidator
    {
        /// <summary>
        /// Exception message that's thrown when there is an improper usage of the framework.
        /// </summary>
        public const string ImproperUseOfFrameworkExceptionMessage = "The parameter validation framework is being used improperly.  See: https://github.com/OBeautifulCode/OBeautifulCode.Validation for documentation on proper usage.";

        /// <summary>
        /// Specifies the name of the parameter.
        /// </summary>
        /// <param name="value">The value of the parameter.</param>
        /// <param name="name">The name of the parameter.</param>
        /// <returns>
        /// The parameter to validate.
        /// </returns>
        public static Parameter Named(
            [ValidatedNotNull] this object value,
            string name)
        {
            if (value is Parameter parameter)
            {
                ThrowOnImproperUseOfFramework(parameter, ParameterShould.NotExist);
            }

            var result = new Parameter
            {
                Value = value,
                Name = name,
                HasBeenNamed = true,
            };

            return result;
        }

        /// <summary>
        /// Initializes a parameter for validation.
        /// </summary>
        /// <param name="value">The value of the parameter.</param>
        /// <returns>
        /// The parameter to validate.
        /// </returns>
        public static Parameter Must(
            [ValidatedNotNull] this object value)
        {
            // it a parameter itself? pass-thru
            if (value is Parameter parameter)
            {
                ThrowOnImproperUseOfFramework(parameter, ParameterShould.BeNamed, ParameterShould.NotBeMusted, ParameterShould.NotBeEached, ParameterShould.NotBeValidated);
                parameter.HasBeenMusted = true;
                return parameter;
            }

            if (value != null)
            {
                // is anonymous type?
                // https://stackoverflow.com/a/15273117/356790
                var valueType = value.GetType();
                if (valueType.Namespace == null)
                {
                    // with one property?  that's the parameter we are trying to validate.
                    var properties = valueType.GetProperties();
                    if (properties.Length == 1)
                    {
                        var parameterInAnonymousObject = new Parameter
                        {
                            Value = properties[0].GetValue(value, null),
                            Name = properties[0].Name,
                            HasBeenMusted = true,
                        };

                        return parameterInAnonymousObject;
                    }
                    else
                    {
                        ThrowOnImproperUseOfFramework(null);
                    }
                }
            }
            
            var directParameter = new Parameter
            {
                Value = value,
                HasBeenMusted = true,
            };

            return directParameter;
        }

        /// <summary>
        /// Specifies that the validations should be applied by iterating
        /// over the <see cref="IEnumerable"/> parameter value.
        /// </summary>
        /// <param name="parameter">The parameter.</param>
        /// <returns>
        /// The parameter who's value should be iterated over when applying validations.
        /// </returns>
        public static Parameter Each(
            [ValidatedNotNull] this Parameter parameter)
        {
            ThrowOnImproperUseOfFramework(parameter, ParameterShould.BeMusted, ParameterShould.NotBeEached);

            if (parameter.Value == null)
            {
                ThrowOnImproperUseOfFramework();
            }

            if (!(parameter.Value is IEnumerable))
            {
                ThrowOnUnexpectedType(nameof(Each), nameof(IEnumerable));
            }

            parameter.HasBeenEached = true;
            return parameter;
        }

        /// <summary>
        /// Specifies another validation.
        /// </summary>
        /// <param name="parameter">The parameter.</param>
        /// <returns>
        /// The parameter to validate.
        /// </returns>
        public static Parameter And(
            [ValidatedNotNull] this Parameter parameter)
        {
            ThrowOnImproperUseOfFramework(parameter, ParameterShould.BeMusted, ParameterShould.BeValidated);
            return parameter;
        }

        internal static void ThrowOnImproperUseOfFramework(
            [ValidatedNotNull] Parameter parameter,
            params ParameterShould[] parameterShoulds)
        {
            bool shouldThrow = false;
            if (parameter == null)
            {
                shouldThrow = true;
            }
            else
            {
                foreach (var parameterShould in parameterShoulds)
                {
                    switch (parameterShould)
                    {
                        case ParameterShould.NotExist:
                            shouldThrow = true;
                            break;
                        case ParameterShould.BeNamed:
                            shouldThrow = !parameter.HasBeenNamed;
                            break;
                        case ParameterShould.NotBeNamed:
                            shouldThrow = parameter.HasBeenNamed;
                            break;
                        case ParameterShould.BeMusted:
                            shouldThrow = !parameter.HasBeenMusted;
                            break;
                        case ParameterShould.NotBeMusted:
                            shouldThrow = parameter.HasBeenMusted;
                            break;
                        case ParameterShould.BeEached:
                            shouldThrow = !parameter.HasBeenEached;
                            break;
                        case ParameterShould.NotBeEached:
                            shouldThrow = parameter.HasBeenEached;
                            break;
                        case ParameterShould.BeValidated:
                            shouldThrow = !parameter.HasBeenValidated;
                            break;
                        case ParameterShould.NotBeValidated:
                            shouldThrow = parameter.HasBeenValidated;
                            break;
                        default:
                            shouldThrow = true;
                            break;
                    }

                    if (shouldThrow)
                    {
                        break;
                    }
                }
            }

            if (shouldThrow)
            {
                ThrowOnImproperUseOfFramework();
            }
        }

        internal static void ThrowOnImproperUseOfFramework()
        {
            // We throw a InvalidOperationException rather than an ArgumentException so that this category of
            // problem (inproper use of the framework), can be clearly differentiated from a validation failure
            // (which will throw ArgumentException or some derivative) by the caller.
            // If we didn't throw here:
            //   - if parameter == null then NullReferenceException would be thrown soon after, when the parameter
            //     gets used, except that it would not have a nice message like the one below.  In addition, we would
            //     have to sprinkle Code Analysis suppressions throughout the project, for CA1062.
            //   - if parameter != null then the user doesn't understand how the framework is designed to be used
            //     and what the framework's limiations are.  Some negative outcome might occur (throwing when
            //     not expected or not throwing when expected).
            throw new InvalidOperationException(ImproperUseOfFrameworkExceptionMessage);
        }

        internal static void ThrowOnUnexpectedType(
            string validationName,
            string expectedType)
        {
            throw new InvalidCastException(Invariant($"called {validationName}() on an object that is not of type {expectedType}"));
        }
    }
}
